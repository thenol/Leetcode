"""
[medium]

有效括号字符串 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「有效括号字符串」部分。

嵌套深度 depth 定义：即有效括号字符串嵌套的层数，depth(A) 表示有效括号字符串 A 的嵌套深度。详情参见题末「嵌套深度」部分。

有效括号字符串类型与对应的嵌套深度计算方法如下图所示：



 

给你一个「有效括号字符串」 seq，请你将其分成两个不相交的有效括号字符串，A 和 B，并使这两个字符串的深度最小。

不相交：每个 seq[i] 只能分给 A 和 B 二者中的一个，不能既属于 A 也属于 B 。
A 或 B 中的元素在原字符串中可以不连续。
A.length + B.length = seq.length
深度最小：max(depth(A), depth(B)) 的可能取值最小。 
划分方案用一个长度为 seq.length 的答案数组 answer 表示，编码规则如下：

answer[i] = 0，seq[i] 分给 A 。
answer[i] = 1，seq[i] 分给 B 。
如果存在多个满足要求的答案，只需返回其中任意 一个 即可。

 

示例 1：

输入：seq = "(()())"
输出：[0,1,1,1,1,0]
示例 2：

输入：seq = "()(())()"
输出：[0,0,0,1,1,0,1,1]
解释：本示例答案不唯一。
按此输出 A = "()()", B = "()()", max(depth(A), depth(B)) = 1，它们的深度最小。
像 [1,1,1,0,0,1,1,1]，也是正确结果，其中 A = "()()()", B = "()", max(depth(A), depth(B)) = 1 。 
 

提示：

1 < seq.size <= 10000
 

有效括号字符串：

仅由 "(" 和 ")" 构成的字符串，对于每个左括号，都能找到与之对应的右括号，反之亦然。
下述几种情况同样属于有效括号字符串：

  1. 空字符串
  2. 连接，可以记作 AB（A 与 B 连接），其中 A 和 B 都是有效括号字符串
  3. 嵌套，可以记作 (A)，其中 A 是有效括号字符串
嵌套深度：

类似地，我们可以定义任意有效括号字符串 s 的 嵌套深度 depth(S)：

  1. s 为空时，depth("") = 0
  2. s 为 A 与 B 连接时，depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是有效括号字符串
  3. s 为嵌套情况，depth("(" + A + ")") = 1 + depth(A)，其中 A 是有效括号字符串

例如：""，"()()"，和 "()(()())" 都是有效括号字符串，嵌套深度分别为 0，1，2，而 ")(" 和 "(()" 都不是有效括号字符串。

https://leetcode.cn/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/description/?source=vscode
"""

"""
思路：
  * 【必要条件】：
    <= 解必然覆盖所有可能性，且为全局最优
    <= 暴力解法，枚举所有可能性，复杂度很高
    <= 由提示知：必然存在 O(N) 解法
    <= 决策聚焦于每一个 seq[i]
  * 【条件转化】
    <= 对每一个 seq[i] 需要知道其 到底放在哪一个集合，集合0，还是集合1
    <= 需要了解的信息：当前集合0的深度、集合1的深度
    <= 直接将当前seq[i]放到深度较低的那一个集合
    <= 进一步优化，直接统计当前seq的深度，将所有深度为奇数的放到集合0，深度为偶数的放到集合1 （注意：栈中始终只会出现“(”字符，“)”不会进栈）
  * 【归纳总结】
    * 栈处理括号并且分配，由于只切割成2个数据集，因此可以直接挨个分配即可
"""

class Solution:
    def maxDepthAfterSplit(self, seq: str) -> List[int]:
        stk = []  # 初始化一个栈，用于存储括号的索引和类型
        res = [0 for i in range(len(seq))]  # 初始化结果数组，长度与输入字符串相同，全部初始化为0
        count = 0  # 初始化计数器，用于计算当前的深度
        for i, c in enumerate(seq):  # 遍历输入字符串中的每个字符及其索引
            if c == '(':  # 如果当前字符是左括号
                stk.append((i, c))  # 将索引和左括号压入栈中
                res[i] = count % 2  # 将当前深度的奇偶性赋值给结果数组
                count += 1  # 深度增加
            elif c == ')':  # 如果当前字符是右括号
                if stk[-1][-1] == '(':  # 如果栈顶是对应的左括号
                    idx, ch = stk.pop()  # 弹出栈顶元素
                    res[i] = res[idx]  # 将左括号对应的结果赋值给当前右括号
                count -= 1  # 深度减少
        return res  # 返回结果数组