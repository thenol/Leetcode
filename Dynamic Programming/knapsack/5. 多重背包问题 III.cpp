//acwing
// 有 N 种物品和一个容量是 V 的背包。

// 第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

// 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
// 输出最大价值。

// 输入格式
// 第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

// 接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。

// 输出格式
// 输出一个整数，表示最大价值。

// 数据范围
// 0<N≤1000
// 0<V≤2000
// 0<vi,wi,si≤2000
// 提示：
// 本题考查多重背包的二进制优化方法。

// 输入样例
// 4 5
// 1 2 3
// 2 4 1
// 3 4 3
// 4 5 2
// 输出样例：
// 10

// use monotonic queue to optimize

/**
 * Analysis:
 * https://www.acwing.com/solution/acwing/content/4237/
 * 解析：
 *  看完全背包转移方程：f[i][j]=max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v]+2w,...,f[i-1][j-sv]+sw)，即找不放i,放1个，放2个，...，放完s个的最大值，
 *  而每个相差都是v，也说明，对于f(i,j)只受和他相差v的倍数的影响，或者只依赖他们，也就是每次必然只能放整数个i,体积为v, 
 *  从而可以换一种遍历方式，按照模余来遍历, 仔细看上面的转移方程，容量的转移本身就是相差v个
 * 故直接就按照模余来遍历：
 *  遍历余数：[0,v-1]:
 *      f[i][j]     =   max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v]+2w,...,f[i-1][j-sv]+sw)
 *      f[i][j-v]   =   max(          f[i-1][j-2v]+w,f[i-1][j-3v]+2w,...,f[i-1][j-sv]+(s-1)w)
 *      f[i][j-3v]  =   max(                         f[i-1][j-2v]+w,,...,f[i-1][j-sv]+(s-2)w)
 *      ...
 *      技巧：如果不用技巧，每次去计算加几个价值的时候比较麻烦
 *      设m % v = d 变换下上面式子可以得出，
 *      f[i, d]    = f[i-1][d]
        f[i, d+v]  = max(f[i-1, d] +w,  f[i-1, d+v])                                    = max(f[i-1, d],  f[i-1, d+v]-w)                                    + w
        f[i, d+2v] = max(f[i-1, d] +2w, f[i-1, d+v] +w,  f[i-1, d+2v])                  = max(f[i-1, d],  f[i-1, d+v]-w, f[i-1, d+2v]-2w)                   + 2w
        f[i, d+3v] = max(f[i-1, d] +3w, f[i-1, d+v] +2w, f[i-1, d+2v]+w,  f[i-1, d+3v]) = max(f[i-1, d],  f[i-1, d+v]-w, f[i-1, d+2v]-2w,  f[i-1, d+3v]-3w) + 3w
        f[i, d+4v] = max(f[i-1, d] +4w, f[i-1, d+v] +3w, f[i-1, d+2v]+2w, f[i-1, d+3v]+w, f[i, d+4v])

 *      
 * 1. 关于>s那个判断：注意
 *  f[i, j ] = f[i-1, j-v]+w, f[i-1, j-2v]+2w, f[i-1, j-3v] +3w,  f[i-1, j-4v]+4w,  ... f[i-1,j-sv]+sw 
 *  只跟前S个有关系，因为假设当前体积为j，那么用当前物品i最多为s个，最多只能用s个，所以窗口大小为s，即维护窗口为s的单调队列，记录最大值，即j-s*v
 * 2. 注意技巧：先减j*w，后加j*w
 */

