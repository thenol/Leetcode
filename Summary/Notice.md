### Common Error
#### Python
* Left-closed, right-open: $ [a,b)\;a<=x<b$
    ```python
    # 1.
    for i in range(n):
        print(i)    # 0,1,2,3...n-1

    # 2. 
    [i if i >3 for i in range(10)] #  Error
    [i if i>3 else 3 for i in range(10)] #  runnable
    [i for i in range(10) if i>3] #  runnable
    ```
    * why is it ? why isn't it left-closed and right-closed
        *  __because the operator $//$, the minimum result is always equal to the left value in the range__
        ```python
            r=[0,1]
            mid=(0+1)//2=0 # which equals to the left of the r.
            # so the minimun value of operator '//' is equal to the left value in the range
            # for example, in binary search, the recursive scale will be (l,mid) (mid,r)
        ```
* Generator and iterator
    * In general, changing variable variables (for instance, the list) should be avoided in loop control
    ```python
    a=[3,4,5,2,1]
    for i in a: # Note the iteration of i is up to the incremental index of the list, i.e. 【i=a[idx++], where idx increments one by one】
        print('i:',i,a.index(i))
        a.remove(i)
        print(a)
    # result:
    i: 3 0
    [4, 5, 2, 1]
    i: 5 1
    [4, 2, 1]
    i: 1 2
    [4, 2]
    # Iterator: Note the index is generated by the generator,
    #  which is actually the increment of the index of the list

    # Another example:
    class MyNumbers:
    def __iter__(self):
        self.a = 1
        return self
    
    def __next__(self):
        x = self.a
        self.a += 1
        return x
    
    myclass = MyNumbers()
    myiter = iter(myclass)
    ```
* Relationship between loop control variables and variable values in loops
    ```python
    i=0
    a = 1
    while i < 5: # map: <i,a>=<0,3>,<1,3>...<4,6>,<5,stop>
        a+=1
        i+=1
    
    # which means the below:(i:value, limit:value, execution times)=>(limit:2, times:limit-i_0=2)
    #   i=0, running the loop, a=1, executed once
    #   i=1, running the loop, a=2, executed twice

    ```
* Notes on operators:
    * $\lfloor\frac{M}{N}\rfloor-1(\frac{N}{N})\le\lfloor\frac{M-1}{N}\rfloor=\lfloor\frac{M}{N}-\frac{1}{N}\rfloor\le\lfloor\frac{M}{N}\rfloor-\lfloor\frac{1}{N}\rfloor\approx\lfloor\frac{M}{N}\rfloor$
    * $\lfloor\frac{M}{N}\rfloor = M//N $

* Infinity:
    ```python
    float('inf')
    float('-inf')
    ```


* Pay attention to learning the new features of the language



* Common Modules:
    * <a href='https://docs.python.org/3/library/collections.html'>Collections:</a>
        * __defaultdic(dict)__:
        ```python
        s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
        d = defaultdict(list) # the list means the type of the value
        for k, v in s:
            d[k].append(v)

        sorted(d.items())
        # output: 
        # [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]
        ```
        * __Counter(dict)__:
        ```python
        #Elements are counted from an iterable or initialized from another mapping (or counter):
        c = Counter()                           # a new, empty counter
        c = Counter('gallahad')                 # a new counter from an iterable
        c = Counter({'red': 4, 'blue': 2})      # a new counter from a mapping
        c = Counter(cats=4, dogs=8)             # a new counter from keyword args
        ```



#### __C++__
* Memset:
    * 第一：memset函数按字节对内存块进行初始化，所以不能用它将int数组初始化为0和-1之外的其他值（除非该值高字节和低字节相同）。
第二：memset(void *s, int ch,size_t n);中ch实际范围应该在0~~255，因为该函数只能取ch的后八位赋值给你所输入的范围的每个字节，比如int a[5]赋值memset（a,-1,sizeof(int )*5）与memset（a,511,sizeof(int )*5） 所赋值的结果是一样的都为-1；因为-1的二进制码为（11111111 11111111 11111111 11111111）而511的二进制码为（00000000 00000000 00000001 11111111）后八位都为（11111111)，所以数组中每个字节，如a[0]含四个字节都被赋值为（11111111），其结果为a[0]（11111111 11111111 11111111 11111111），即a[0]=-1，因此无论ch多大只有后八位二进制有效，而后八位二进制的范围在（0~255）中改。而对字符数组操作时则取后八位赋值给字符数组，其八位值作为ASCII码。
    * 可以设置<a href='https://www.cnblogs.com/LLGemini/p/4309660.html'>无穷大</a> 0x3f3f3f3f int_max
* Performence:
```c++
    在竞赛中，一般计算机一秒能运行5 x 10^8次计算，如果题目给出的时间限制カ1s,那么你选择的算法执行的计算次数最多应该在10^8量级才有可能解决这个题目。一般 O(n)的算法能解决的数据范围在n < 10^8。

      O(n *logn)的算法能解决的数据范围在n <= 10^6。

      O(n*sqrt(n) )的算法能解决的数据范围在n < 10^5。

      O(n^2)的算法能解决的数据范围在n<5000。

      O(n^3)的算法能解决的数据范围在n <300。

      O(2^n)的算法能解决的数据范围在n < 25。

      O(n!)的算法能解决的数据范围在n < 11。
```


* 边界：
    ```c++
    #include<iostream>
    #include<cmath>
    using namespace std;
    int main()
    {
        //int -2147483648~2147483647    2^32 (21亿)
        cout << INT_MIN <<endl;
        cout << INT_MAX <<endl;
        //unsigned int 4294967295        2^32
        cout << UINT32_MAX <<endl;
        //long long        9223372036854775807        2^64 （92亿亿）
        cout << LONG_LONG_MAX <<endl;
        cout << LONG_LONG_MIN <<endl;
        //unsigned long long    18446744073709551615    2^64
        cout << UINT64_MAX <<endl;
        return 0;
    }
    ```